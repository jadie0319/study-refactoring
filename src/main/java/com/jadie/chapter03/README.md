# Chapter03 - 코드에서 나는 악취

## 3.1 기이한 이름

- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다

## 3.2 중복 코드

- 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다
- 코드 중복 예
  - 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우, `함수 추출하기` 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다
  - 먼저 문장 `슬라이드하기`로 비슷한 부분을 한곳에 모아 `함수 추출하기`를 더 쉽게 적용할 수 있는지 살펴본다.

## 3.3 긴 함수

- 짧은 코드는 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점을 준다
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.
- 본문을 보지 않아도 되기 때문이다
- `무엇을 하는지` 를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.
- 반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다
  - 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면 성격이 다른 두가지 작업이 섞여 있기 때문. `반복문 쪼개기`를 적용해서 작업을 분리한다.

## 3.4 긴 매개변수 목록

- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있다면? 이런 매개변수는 `매개변수를 질의 함수로 바꾸기`로 제거할 수 있다.
- `객체 통째로 넘기기`, `매개변수 객체 만들기` 를 적용해서 매개변수 수를 줄일 수도 있다. 

## 3.5 전역 데이터

- 전역 데이터는 가장 지독한 악취에 속한다
  - 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없는게 문제다
- `변수 캡슐화하기` 로 방지할 수 있다.
  - 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 적용한다
  - 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있다

## 3.6 가변 데이터

- 데이터를 변경했을 때 예상치 못한 결과나 버그로 이어지는 경우가 발생할 수 있다
- 함수형 프로그래밍에선 데이터는 절대 안변하고, 변경하려면 반드시 복사본을 만들어서 반환한다는 개념을 기본으로 하고 있다
- 내부 필드에 데이터를 담고 있는 변수라면 `참조를 값으로 바꾸기`를 적용하여 내부 필드를 수정하지 말고 구조체를 교체한다

## 3.7 뒤엉킨 변경

- 단일책임원칙(SRP)이 지켜지지 않을 때 발생한다
- 하나의 모듈이 서로 다른 이유들로 인해 여러 방식으로 변경되는 일이 많을 때 발생한다

## 3.8 산탄총 수술

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생
- 해결
  - `함수 옮기기`, `필드 옮기기`로 모두 한 모듈에 묶어버린다
  - 비슷한 데이터를 다루는 함수가 많다면 `여러 함수를 클래스로 묶기` 적용
  - 어설프게 분리된 로직을 `함수 인라인`, `클래스 인라인` 으로 합치는 것도 좋다.

## 3.9 기능 편애

- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 많을 때 생김
- `함수 옮기기`를 통해 이 함수를 필요한 데이터가 있는 모듈로 옮겨주면 된다.
- `전략 패턴`과 `방문자 패턴`을 적용하면 오버라이드해야 할 소량의 동작 코드를 각각의 클래스로 격리해주므로 수정하기가 쉬워진다

## 3.10 데이터 뭉치

- 데이터 항목 서너개가 여러 곳에서 함께 뭉쳐 다니는 모습이 보임
- `클래스 추출하기`로 하나의 객체로 묶는다.
- 데이터 뭉치 확인법
  - 값 하나를 삭제해보자. 이때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻

## 3.11 기본형 집착

- 기초 타입(화폐,좌표,구간)을 직접 정의하기 꺼리는 사람이 많다
- `기본형을 객체로 바꾸기`를 적용하면 의미있게 변경할 수 있다.
- 같이 사용되는 기본형 그룹도 데이터 뭉치다. 클래스 추출, 매개변수 객체 만들기를 이용하여 변경 가능

## 3.12 반복되는 switch 문

- `조건부 로직을 다형성으로 바꾸기`로 없앨 수 있다.
- 모든 스위치 문이 문제는 아니다
- 문제는 조건절을 하나 추가할 때마다 다른 스위치문들도 모두 찾아서 함께 수정해야 되기 때문이다.
- 다형성을 고려하자

## 3.13 반복문

- `반복문을 파이프라인으로 바꾸기` 를 적용해서 시대에 걸맞지 않은 반복문을 제거할 수 있다.

## 3.14 성의 없는 요소

- 몬분 코드를 그대로 쓰는 것과 다름 없거나 실질적으로 메서드가 하나뿐인 클래스도 있다.
- `함수 인라인`, `클래스 인라인`, 또는 상속을 사용한다면 `계층 합치기`를 사용해 해결가능하다

## 3.15 추측성 일반화

- **나중에 필요할 거야** 라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리를 작성해둔 코드에서 발생
- 미래를 대비한 코드를 실제로 사용한다면 다행이지만 그렇지 않으면 낭비다

## 3.16 임시 필드

- 사용되지 않는 필드가 있다면 클래스 추출하기, 함수 옮기기 로 임시 필드들과 관련된 코드를 새 클래스로 옮긴다.

## 3.17 메시지 체인

- 메시지 체인 : 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식
- 클라이언트 코드가 객체 네비게이션 구조에 종속됐음을 의미
- `위임 숨기기` 로 해결한다

## 3.18 중개자

- 객체 기능 중 하나로 외부로부터 세부사항을 숨겨주는 캡슐화가 있다.
- 캡슐화 과정에서 위임이 자주 활용된다.
- 위임이 지나치면 문제가 된다.
  - 클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면?
  - 중개자 제거하기를 통해 실제로 일을 하는 객체와 직접 소통하게 하자

## 3.19 내부자 거래

- 모듈 사이의 데이터 거래가 많으면 결합도가 높아진다.
- 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제 3의 모듈을 만든다
- 또는 위임 숨기기를 이용하여 다른 모듈이 중간자 역할을 하게 만든다.
- 부모,자식 사이의 결탁은 12장의 `서브클래스를 위임으로 바꾸기`, `슈퍼클래스를 위임으로 바꾸기` 활용하자.

## 3.20 거대한 클래스

- 한 클래스가 너무 많을 하면 필드가 늘어난다.
- 필드의 일부를 따로 묶어 추출한다.
- 필드와 마찬가지로 코드량이 너무 많은 클래스도 중복코드와 혼동을 일으킬 수 있다
  - 공통 부분 중복을 제거한다

## 3.21 서로 다른 인터페이스의 대안 클래스들

- 클래스 교체는 인터페이스가 같아야 한다. 함수 선언 바꾸기를 이용하여 시그니처를 일치 시킨다.
- 함수 옮기기를 이용하여 인터페이스가 같아질 때까지 필요한 동작을 클래스 안으로 밀어 넣는다.

## 3.22 데이터 클래스

- 데이터 클래스란 데이터 필드와 게터/세터로만 구성된 클래스를 말한다.
- 다른 클래스에서 접근할 수 없게 레코드 갭슐화하기로 숨기자.
- 세터 제거로 원천 봉쇄한다.

## 3.23 상속포기

- 서브클래스가 부모의 동작은 필요하지만 인터페이스는 따르고 싶지 않을 때 상속포기 냄새가 난다.
- 서브클래스는 부모로부터 메서드와 데이터를 물려받는다
- 부모의 유산을 원치 않거나 필요없으면?
  - 같은 계층에 서브클래스를 하나 새로 믄들고
  - 메서드 내리기, 필드 내리기를 활용해서 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다
  - 그러면 부모에는 공통된 부분만 남는다

## 3.24 주석

- 주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제 처럼 사용할 때다.
- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다.


